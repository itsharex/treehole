// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/Jazee6/treehole/cmd/account/model"
)

func newCampu(db *gorm.DB, opts ...gen.DOOption) campu {
	_campu := campu{}

	_campu.campuDo.UseDB(db, opts...)
	_campu.campuDo.UseModel(&model.Campu{})

	tableName := _campu.campuDo.TableName()
	_campu.ALL = field.NewAsterisk(tableName)
	_campu.ID = field.NewUint32(tableName, "id")
	_campu.Name = field.NewString(tableName, "name")
	_campu.Code = field.NewString(tableName, "code")
	_campu.Department = field.NewString(tableName, "department")
	_campu.Location = field.NewString(tableName, "location")
	_campu.Level = field.NewString(tableName, "level")
	_campu.Remark = field.NewString(tableName, "remark")

	_campu.fillFieldMap()

	return _campu
}

type campu struct {
	campuDo

	ALL        field.Asterisk
	ID         field.Uint32
	Name       field.String
	Code       field.String
	Department field.String
	Location   field.String
	Level      field.String
	Remark     field.String

	fieldMap map[string]field.Expr
}

func (c campu) Table(newTableName string) *campu {
	c.campuDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c campu) As(alias string) *campu {
	c.campuDo.DO = *(c.campuDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *campu) updateTableName(table string) *campu {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewUint32(table, "id")
	c.Name = field.NewString(table, "name")
	c.Code = field.NewString(table, "code")
	c.Department = field.NewString(table, "department")
	c.Location = field.NewString(table, "location")
	c.Level = field.NewString(table, "level")
	c.Remark = field.NewString(table, "remark")

	c.fillFieldMap()

	return c
}

func (c *campu) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *campu) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 7)
	c.fieldMap["id"] = c.ID
	c.fieldMap["name"] = c.Name
	c.fieldMap["code"] = c.Code
	c.fieldMap["department"] = c.Department
	c.fieldMap["location"] = c.Location
	c.fieldMap["level"] = c.Level
	c.fieldMap["remark"] = c.Remark
}

func (c campu) clone(db *gorm.DB) campu {
	c.campuDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c campu) replaceDB(db *gorm.DB) campu {
	c.campuDo.ReplaceDB(db)
	return c
}

type campuDo struct{ gen.DO }

type ICampuDo interface {
	gen.SubQuery
	Debug() ICampuDo
	WithContext(ctx context.Context) ICampuDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ICampuDo
	WriteDB() ICampuDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ICampuDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ICampuDo
	Not(conds ...gen.Condition) ICampuDo
	Or(conds ...gen.Condition) ICampuDo
	Select(conds ...field.Expr) ICampuDo
	Where(conds ...gen.Condition) ICampuDo
	Order(conds ...field.Expr) ICampuDo
	Distinct(cols ...field.Expr) ICampuDo
	Omit(cols ...field.Expr) ICampuDo
	Join(table schema.Tabler, on ...field.Expr) ICampuDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ICampuDo
	RightJoin(table schema.Tabler, on ...field.Expr) ICampuDo
	Group(cols ...field.Expr) ICampuDo
	Having(conds ...gen.Condition) ICampuDo
	Limit(limit int) ICampuDo
	Offset(offset int) ICampuDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ICampuDo
	Unscoped() ICampuDo
	Create(values ...*model.Campu) error
	CreateInBatches(values []*model.Campu, batchSize int) error
	Save(values ...*model.Campu) error
	First() (*model.Campu, error)
	Take() (*model.Campu, error)
	Last() (*model.Campu, error)
	Find() ([]*model.Campu, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Campu, err error)
	FindInBatches(result *[]*model.Campu, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Campu) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ICampuDo
	Assign(attrs ...field.AssignExpr) ICampuDo
	Joins(fields ...field.RelationField) ICampuDo
	Preload(fields ...field.RelationField) ICampuDo
	FirstOrInit() (*model.Campu, error)
	FirstOrCreate() (*model.Campu, error)
	FindByPage(offset int, limit int) (result []*model.Campu, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ICampuDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c campuDo) Debug() ICampuDo {
	return c.withDO(c.DO.Debug())
}

func (c campuDo) WithContext(ctx context.Context) ICampuDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c campuDo) ReadDB() ICampuDo {
	return c.Clauses(dbresolver.Read)
}

func (c campuDo) WriteDB() ICampuDo {
	return c.Clauses(dbresolver.Write)
}

func (c campuDo) Session(config *gorm.Session) ICampuDo {
	return c.withDO(c.DO.Session(config))
}

func (c campuDo) Clauses(conds ...clause.Expression) ICampuDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c campuDo) Returning(value interface{}, columns ...string) ICampuDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c campuDo) Not(conds ...gen.Condition) ICampuDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c campuDo) Or(conds ...gen.Condition) ICampuDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c campuDo) Select(conds ...field.Expr) ICampuDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c campuDo) Where(conds ...gen.Condition) ICampuDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c campuDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ICampuDo {
	return c.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (c campuDo) Order(conds ...field.Expr) ICampuDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c campuDo) Distinct(cols ...field.Expr) ICampuDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c campuDo) Omit(cols ...field.Expr) ICampuDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c campuDo) Join(table schema.Tabler, on ...field.Expr) ICampuDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c campuDo) LeftJoin(table schema.Tabler, on ...field.Expr) ICampuDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c campuDo) RightJoin(table schema.Tabler, on ...field.Expr) ICampuDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c campuDo) Group(cols ...field.Expr) ICampuDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c campuDo) Having(conds ...gen.Condition) ICampuDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c campuDo) Limit(limit int) ICampuDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c campuDo) Offset(offset int) ICampuDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c campuDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ICampuDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c campuDo) Unscoped() ICampuDo {
	return c.withDO(c.DO.Unscoped())
}

func (c campuDo) Create(values ...*model.Campu) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c campuDo) CreateInBatches(values []*model.Campu, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c campuDo) Save(values ...*model.Campu) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c campuDo) First() (*model.Campu, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Campu), nil
	}
}

func (c campuDo) Take() (*model.Campu, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Campu), nil
	}
}

func (c campuDo) Last() (*model.Campu, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Campu), nil
	}
}

func (c campuDo) Find() ([]*model.Campu, error) {
	result, err := c.DO.Find()
	return result.([]*model.Campu), err
}

func (c campuDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Campu, err error) {
	buf := make([]*model.Campu, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c campuDo) FindInBatches(result *[]*model.Campu, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c campuDo) Attrs(attrs ...field.AssignExpr) ICampuDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c campuDo) Assign(attrs ...field.AssignExpr) ICampuDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c campuDo) Joins(fields ...field.RelationField) ICampuDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c campuDo) Preload(fields ...field.RelationField) ICampuDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c campuDo) FirstOrInit() (*model.Campu, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Campu), nil
	}
}

func (c campuDo) FirstOrCreate() (*model.Campu, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Campu), nil
	}
}

func (c campuDo) FindByPage(offset int, limit int) (result []*model.Campu, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c campuDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c campuDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c campuDo) Delete(models ...*model.Campu) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *campuDo) withDO(do gen.Dao) *campuDo {
	c.DO = *do.(*gen.DO)
	return c
}
